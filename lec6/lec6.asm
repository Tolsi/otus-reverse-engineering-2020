; HEX NUMBERS SUM APP
FIRST_SIZE_OFFSET = 1F00H
SECOND_SIZE_OFFSET = 1F02H
RESULT_SIZE_OFFSET = 1F04H


MAIN PROC NEAR
    XOR AX, AX
    XOR DI, DI
    MOV DX, 200H
    MOV ES, DX
    LEA SI, ENTER_FIRST
    CALL PRINT_STRING
    CALL READ_HEX
    LEA SI, ENTER_SECOND
    CALL PRINT_STRING
    SUB DI, 2
    MOV ES:[FIRST_SIZE_OFFSET], DI 
    ADD DI, 2
    CALL READ_HEX
    SUB DI, 2
    MOV ES:[SECOND_SIZE_OFFSET], DI
    ADD DI, 2
    LEA SI, RESULT
    CALL PRINT_STRING
    CALL SUM_BY_BYTES
    CALL PRINT_HEX_NUMBER
    CALL EXIT
MAIN ENDP 

EXIT PROC NEAR
    MOV AH, 4CH ; SERVICE 4CH - TERMINATE WITH ERROR CODE
    MOV AL, 0 ; ERROR CODE
    INT 21H ; INTERRUPT 21H - DOS GENERAL INTERRUPTS
    RET    
EXIT ENDP

; CHECKS CHAR FROM AL REGISTER FOR HEX NUMBER AND CONVERT THEM
AL_TO_HEX_NUMBER_AND_CHECK_HEX_CHAR PROC NEAR
    CMP AL, '0'
    JL AL_TO_HEX_ERROR
    CMP AL, '9'
    JG LETTER
    SUB AL, 48
    JMP AL_TO_HEX_RETURN
    
    LETTER:
    CMP AL, 'Z'
    JLE AFTER_UPPERCASE
    SUB AL, 20H
    
    AFTER_UPPERCASE:
    CMP AL, 'F'
    JG AL_TO_HEX_ERROR

    CMP AL, 'A'
    JL AL_TO_HEX_ERROR
    SUB AL, 55
    JMP AL_TO_HEX_RETURN
    
    AL_TO_HEX_ERROR:
    CALL PRINT_NEW_LINE    
    LEA SI, CHAR_ERROR 
    CALL PRINT_STRING
    MOV AH, 4CH ; SERVICE 4CH - TERMINATE WITH ERROR CODE
    MOV AL, 1 ; ERROR CODE
    INT 21H ; INTERRUPT 21H - DOS GENERAL INTERRUPTS
    
    AL_TO_HEX_RETURN:
    RET    
AL_TO_HEX_NUMBER_AND_CHECK_HEX_CHAR ENDP

               
; RESULT: CX - NUM BYTES LEN, DS[0]:DS[SI] - HEX NUMBER BY BYTES
; USE AX, DX, DI 
READ_HEX PROC NEAR
    XOR CX, CX
    INPUT:                                  
    MOV AH, 1
    INT 21H
    CMP AL, 13
    JE READ_HEX_RETURN
    CALL AL_TO_HEX_NUMBER_AND_CHECK_HEX_CHAR
    STOSB
    INC CX
    JMP INPUT
    READ_HEX_RETURN:
    ; WRITE STR SIZE TO NEXT WORD AFTER STRING   
    MOV AX, CX
    STOSW
    CALL PRINT_NEW_LINE
    RET
READ_HEX ENDP
    
; OFFSET1 = 200H
; LEN1 = [FIRST_SIZE_OFFSET] PTR AS WORD

; OFFSET2 = 200H+[FIRST_SIZE_OFFSET]+2
; LEN2 =  [SECOND_SIZE_OFFSET] PTR AS WORD
;
; RETURN ES:SI - START RETURN NUMBER, DX - LEN
SUM_BY_BYTES PROC NEAR
   ; DX = MAX RESULT SIZE = MAX(BX, AX) + 1
   MOV SI, ES:FIRST_SIZE_OFFSET
   MOV AX, ES:SI
   MOV SI, ES:SECOND_SIZE_OFFSET
   MOV BX, ES:SI
   CMP AX, BX
   JG FIRST_GREATER
   MOV DX, BX
   JMP AFTER_MAX
   FIRST_GREATER:
   MOV DX, AX
   AFTER_MAX:
   INC DX
   ; START FROM THE END, SUM BY 1 BYTE FROM EACH NUMBER
   XOR AL, AL
   MOV CX, DX
   REP STOSB
   DEC DI
   DEC DX 
   ; SHIFT I FROM END TO END-1, LOOP
   XOR CX, CX
   SUM_BY_BYTES_LOOP:
   MOV SI, ES:FIRST_SIZE_OFFSET
   MOV AX, ES:SI
   CMP AX, CX
   JLE MAY_BE_SUM_SECOND
   CALL SUM_BYTE_FROM_SI_POINTER    
   MAY_BE_SUM_SECOND:
   MOV SI, ES:SECOND_SIZE_OFFSET
   MOV AX, ES:SI
   CMP AX, CX
   JLE AFTER_SUM
   CALL SUM_BYTE_FROM_SI_POINTER
   AFTER_SUM:
   ; TODO - CHECK > 32 AND MOVE 1
   MOV SI, DI
   SUB SI, CX
   CMP ES:[SI], 0FH
   JLE SUM_BY_BYTES_END_LOOP
   SUB ES:[SI], 10H
   DEC SI
   MOV ES:[SI], 01H
   SUM_BY_BYTES_END_LOOP: 
   INC CX
   CMP CX, DX
   JE SUM_BY_BYTES_MAY_BE_INC_LEN 
   JMP SUM_BY_BYTES_LOOP 
   SUM_BY_BYTES_MAY_BE_INC_LEN:
   MOV SI, DI
   SUB SI, DX
   CMP ES:[SI], 1
   JNE SUM_BY_BYTES_END
   INC DX
   DEC SI
   SUM_BY_BYTES_END:
   INC SI 
   RET
SUM_BY_BYTES ENDP

SUM_BYTE_FROM_SI_POINTER PROC NEAR
   DEC SI
   SUB SI, CX
   MOV AL, ES:SI
   MOV SI, DI
   SUB SI, CX
   ADD ES:[SI], AL
   RET
SUM_BYTE_FROM_SI_POINTER ENDP


; PRINT HEX HUMBER TO ASCII HEX BYTE
; OFFSET ES:SI
; LEN DX
PRINT_HEX_NUMBER PROC NEAR
  MOV BX, DX
  XOR CX, CX
  PRINT_HEX_NUMBER_LOOP:
  MOV DL, ES:[SI]
  CMP DL, 9
  JG PRINT_HEX_NUMBER_LETTER
  ADD DL, 30H
  JMP PRINT_HEX_NUMBER_PRINT
  PRINT_HEX_NUMBER_LETTER:
  ADD DL, 55
  PRINT_HEX_NUMBER_PRINT:
  MOV AH, 2
  INT 0X21
  INC CX
  INC SI
  CMP CX, BX
  JL PRINT_HEX_NUMBER_LOOP
  RET
PRINT_HEX_NUMBER ENDP

; SI - STRING START POINTER
PRINT_STRING PROC NEAR
    PRINT_STRING_LOOP:
    MOV DL, [SI]
    CMP DL, 0
    JE PRINT_STRING_END
    MOV AH, 2
    INT 0X21
    INC SI
    JMP PRINT_STRING_LOOP
    PRINT_STRING_END:
    CALL PRINT_NEW_LINE
    RET
PRINT_STRING ENDP

PRINT_NEW_LINE PROC NEAR  
    MOV DL, 10
    MOV AH, 02H
    INT 21H
    MOV DL, 13
    INT 21H
    RET
PRINT_NEW_LINE ENDP

ENTER_FIRST DB "ENTER FIRST HEX NUMBER:", 0
ENTER_SECOND DB "ENTER SECOND HEX NUMBER:", 0
RESULT DB "RESULT:", 0
CHAR_ERROR DB "INVALID HEX CHAR!", 0